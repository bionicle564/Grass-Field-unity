// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
struct GrassData
{
    float4 position;
};

RWStructuredBuffer<GrassData> grassBuffer;
RWStructuredBuffer<uint> count;

Texture2D<float3> hightMap;
SamplerState sampler_linear_repeat;

float2 groundSize;
float heightScale;

float sideLength;

uint density;

uint grassCount;

float4 camPos;


[numthreads(64,1,1)] //groups of 64
void CSMain (uint3 id : SV_DispatchThreadID)
{
    uint index = id.x;

    //float u = (float)index / grassCount;
    

    GrassData g;
    float x = index % (sideLength * density);
    float z = index / (sideLength * density);
    
    x *= 1.f / density;
    z *= 1.f / density;
    
    float2 uv;
    uv.x = x / sideLength;
    uv.y = z / sideLength;

    float4 hightMapST = float4(1,1,0,0);

    uv = uv * hightMapST.xy + hightMapST.zw;


    float displace = hightMap.SampleLevel(sampler_linear_repeat, uv, 0).r;

    float preDis = displace;
    
    
    
    displace *= heightScale;
    displace -= 1.5;

    x -= sideLength / 2;
    z -= sideLength / 2;
    
    //x += 2;

    g.position = float4(x, displace, z, 0);
    
    float3 viewPos = camPos;
    float inFrontOfCam = dot(viewPos, g.position.xyz - viewPos);
    
    if (inFrontOfCam < 0)
    {
        InterlockedAdd(count[0],1);
    }
    
    g.position.w = inFrontOfCam;
    
    grassBuffer[index] = g;

}
